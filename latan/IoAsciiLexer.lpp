%option reentrant
%option prefix="_ioAscii_"
%option bison-bridge
%option bison-locations
%option noyywrap
%option yylineno

%{
    #include <iostream>
	#include <latan/IO.hpp>
	#include <latan/IOASCIIParser.hpp>
    #pragma GCC diagnostic ignored "-Wsign-compare"
    #pragma GCC diagnostic ignored "-Wunused-function"
    #pragma GCC diagnostic ignored "-Wunused-parameter"

    using namespace std;
    using namespace Latan;
    
	#define YY_EXTRA_TYPE  AsciiFile::AsciiParserState*
	#define YY_USER_ACTION \
    yylloc->first_line   = yylloc->last_line = yylineno;\
    yylloc->first_column = yylloc->last_column + 1;\
    yylloc->last_column  = yylloc->first_column + yyleng - 1;

	#define YY_INPUT(buf, result, max_size) \
	{ \
        (*yyextra->stream).read(buf,max_size);\
        result = (*yyextra->stream).gcount();\
	}
    
    #define YY_DEBUG 0
    #if (YY_DEBUG == 1)
    #define RETTOK(tok) cout << #tok << "(" << yytext << ")" << endl; return tok
    #else
    #define RETTOK(tok) return tok
    #endif
%}

DIGIT   [0-9]
ALPHA   [a-zA-Z_]
SIGN    \+|-
EXP     e|E
INT     {SIGN}?{DIGIT}+
FLOAT   {SIGN}?(({DIGIT}+\.{DIGIT}*)|({DIGIT}*\.{DIGIT}+))({EXP}{SIGN}?{INT}+)?
LMARK   #L
BLANK   [ \t]

%x MARK TYPE

%%

{LMARK}            {BEGIN(MARK);}
{INT}              {yylval->val_int = strTo<int>(yytext); RETTOK(INT);}
{FLOAT}            {yylval->val_double = strTo<double>(yytext); RETTOK(FLOAT);}
({ALPHA}|{DIGIT})+ {strcpy(yylval->val_str,yytext); RETTOK(ID);}
<MARK>latan_begin  {BEGIN(TYPE); RETTOK(OPEN);}
<MARK>latan_end    {BEGIN(TYPE); RETTOK(CLOSE);}
<TYPE>mat          {BEGIN(INITIAL); RETTOK(MAT);}
<*>\n              {yylloc->last_column = 0;}
<*>[ \t]
<*>.               {yylval->val_char = yytext[0]; RETTOK(ERR);}

%%

void AsciiFile::AsciiParserState::initScanner()
{
	yylex_init(&scanner);
	yyset_extra(this, scanner);
}

void AsciiFile::AsciiParserState::destroyScanner()
{
	yylex_destroy(scanner);
}
