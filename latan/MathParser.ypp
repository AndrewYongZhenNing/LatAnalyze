%{
    #include <iostream>
    #include <sstream>
    #include <cstring>
    #include <latan/Global.hpp>
	#include <latan/MathCompiler.hpp>

    using namespace std;
    using namespace Latan;
%}

%pure-parser
%name-prefix="_math_"
%locations
%defines
%error-verbose
%parse-param { Latan::MathCompiler::MathParserState *state }
%initial-action {yylloc.last_column = 0;}
%lex-param { void* scanner }

%union
{
	double           val_double;
    char             val_char;
    char             val_str[MAXIDLENGTH];
    Latan::MathNode *val_node;
}

%token <val_char> ERR
%token <val_str>  FLOAT
%token <val_str>  ID
%token <val_str>  KEYWORD

%left '='
%left '+' '-'
%left '*' '/'
%left '^'
%nonassoc UMINUS

%type <val_node> expr
%type <val_node> funcargs

%{
	int _math_lex(YYSTYPE *lvalp, YYLTYPE *llocp, void *scanner);

	void _math_error(YYLTYPE *locp, MathCompiler::MathParserState *state,
                     const char *err)
	{
        stringstream buf;
        
        buf << *(state->streamName) << ":" << locp->first_line << ":"\
            << locp->first_column << ": " << err;
        LATAN_ERROR(Parsing, buf.str());
	}

	#define scanner state->scanner
%}

%%

program:
     /* empty string */
    | program expr ';' {state->data->push_back($2);}
    ;

expr:
      FLOAT
    {$$ = new MathNode($FLOAT, MathNode::Type::cst);}
    | ID
    {$$ = new MathNode($ID,MathNode::Type::var);}
    | ID '=' expr
    {
        $$ = new MathNode("=", MathNode::Type::op, 2,              \
                          new MathNode($ID,MathNode::Type::var), $3);
    }
    | 'r' expr
    {$$ = new MathNode("return", MathNode::Type::keyw, 1, $2);}
    | '-' expr %prec UMINUS
    {$$ = new MathNode("-", MathNode::Type::op, 1, $2);}
    | expr '+' expr
    {$$ = new MathNode("+", MathNode::Type::op, 2, $1, $3);}
    | expr '-' expr
    {$$ = new MathNode("-", MathNode::Type::op, 2, $1, $3);}
    | expr '*' expr
    {$$ = new MathNode("*", MathNode::Type::op, 2, $1, $3);}
    | expr '/' expr
    {$$ = new MathNode("/", MathNode::Type::op, 2, $1, $3);}
    | expr '^' expr
    {$$ = new MathNode("^", MathNode::Type::op, 2, $1, $3);}
    | '(' expr ')'
    {$$ = $2;}
    | ID '(' funcargs ')'
    {$$ = $3; $$->setName($ID);}
    ;

funcargs:
     /* empty string */
    {$$ = new MathNode("", MathNode::Type::func);}
    | expr
    {$$ = new MathNode("", MathNode::Type::func, 1, $1);}
    | funcargs ',' expr
    {$$ = $1; $$->pushArg($3);}
    ;

